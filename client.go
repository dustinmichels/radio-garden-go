// Package radiogarden provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version (devel) DO NOT EDIT.
package radiogarden

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
)

// Channel defines model for Channel.
type Channel struct {
	Country *struct {
		Id    *string `json:"id,omitempty"`
		Title *string `json:"title,omitempty"`
	} `json:"country,omitempty"`
	Id    *string `json:"id,omitempty"`
	Place *struct {
		Id    *string `json:"id,omitempty"`
		Title *string `json:"title,omitempty"`
	} `json:"place,omitempty"`
	Secure  *bool   `json:"secure,omitempty"`
	Title   *string `json:"title,omitempty"`
	Url     *string `json:"url,omitempty"`
	Website *string `json:"website,omitempty"`
}

// ChannelPlaceRef defines model for ChannelPlaceRef.
type ChannelPlaceRef struct {
	// Embedded struct due to allOf(#/components/schemas/ChannelRef)
	ChannelRef `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Map      *string `json:"map,omitempty"`
	Subtitle *string `json:"subtitle,omitempty"`
}

// ChannelRef defines model for ChannelRef.
type ChannelRef struct {
	Href  *string `json:"href,omitempty"`
	Title *string `json:"title,omitempty"`
}

// ChannelRefs defines model for ChannelRefs.
type ChannelRefs struct {
	Items     *[]ChannelRef `json:"items,omitempty"`
	ItemsType *string       `json:"itemsType,omitempty"`
	Type      *string       `json:"type,omitempty"`
}

// Cities defines model for Cities.
type Cities struct {
	Items          *[]LeftPageRef `json:"items,omitempty"`
	RightAccessory *string        `json:"rightAccessory,omitempty"`
	Title          *string        `json:"title,omitempty"`
	Type           *string        `json:"type,omitempty"`
}

// CountryPopularStations defines model for CountryPopularStations.
type CountryPopularStations struct {
	Items     *[]CountryPopularStations_Items_Item `json:"items,omitempty"`
	ItemsType *string                              `json:"itemsType,omitempty"`
	Title     *string                              `json:"title,omitempty"`
	Type      *string                              `json:"type,omitempty"`
}

// CountryPopularStations_Items_Item defines model for CountryPopularStations.items.Item.
type CountryPopularStations_Items_Item struct {
	union json.RawMessage
}

// CountryRef defines model for CountryRef.
type CountryRef struct {
	Map   *[]float32 `json:"map,omitempty"`
	Title *string    `json:"title,omitempty"`
	Url   *string    `json:"url,omitempty"`
}

// Geolocation defines model for Geolocation.
type Geolocation struct {
	City        *string  `json:"city,omitempty"`
	CountryCode *string  `json:"country_code,omitempty"`
	CountryName *string  `json:"country_name,omitempty"`
	Ip          *string  `json:"ip,omitempty"`
	Latitude    *float32 `json:"latitude,omitempty"`
	Longitude   *float32 `json:"longitude,omitempty"`
	MetroCode   *int32   `json:"metro_code,omitempty"`
	RegionCode  *string  `json:"region_code,omitempty"`
	RegionName  *string  `json:"region_name,omitempty"`
	TimeZone    *string  `json:"time_zone,omitempty"`
	ZipCode     *string  `json:"zip_code,omitempty"`
}

// LeftPageRef defines model for LeftPageRef.
type LeftPageRef struct {
	LeftAccessory      *string   `json:"leftAccessory,omitempty"`
	LeftAccessoryCount *int32    `json:"leftAccessoryCount,omitempty"`
	Page               *PlaceRef `json:"page,omitempty"`
	Title              *string   `json:"title,omitempty"`
}

// LocalPickStations defines model for LocalPickStations.
type LocalPickStations struct {
	Items     *[]ChannelPlaceRef `json:"items,omitempty"`
	ItemsType *string            `json:"itemsType,omitempty"`
	Title     *string            `json:"title,omitempty"`
	Type      *string            `json:"type,omitempty"`
}

// LocalPopularStations defines model for LocalPopularStations.
type LocalPopularStations struct {
	ActionPage *PlaceRef     `json:"actionPage,omitempty"`
	ActionText *string       `json:"actionText,omitempty"`
	Items      *[]ChannelRef `json:"items,omitempty"`
	ItemsType  *string       `json:"itemsType,omitempty"`
	Title      *string       `json:"title,omitempty"`
	Type       *string       `json:"type,omitempty"`
}

// MoreRef defines model for MoreRef.
type MoreRef struct {
	Page           *MoreRef_Page `json:"page,omitempty"`
	RightAccessory *string       `json:"rightAccessory,omitempty"`
	Title          *string       `json:"title,omitempty"`
	Type           *string       `json:"type,omitempty"`
}

// MoreRef_Page defines model for MoreRef.Page.
type MoreRef_Page struct {
	union json.RawMessage
}

// NearbyPlaces defines model for NearbyPlaces.
type NearbyPlaces struct {
	Items          *[]RightPageRef `json:"items,omitempty"`
	RightAccessory *string         `json:"rightAccessory,omitempty"`
	Title          *string         `json:"title,omitempty"`
	Type           *string         `json:"type,omitempty"`
}

// Place defines model for Place.
type Place struct {
	Boost   *bool      `json:"boost,omitempty"`
	Country *string    `json:"country,omitempty"`
	Geo     *[]float32 `json:"geo,omitempty"`
	Id      *string    `json:"id,omitempty"`
	Size    *int32     `json:"size,omitempty"`
	Title   *string    `json:"title,omitempty"`
	Url     *string    `json:"url,omitempty"`
}

// PlaceContent defines model for PlaceContent.
type PlaceContent struct {
	Content *[]PlaceContent_Content_Item `json:"content,omitempty"`
}

// PlaceContent_Content_Item defines model for PlaceContent.content.Item.
type PlaceContent_Content_Item struct {
	union json.RawMessage
}

// PlaceRef defines model for PlaceRef.
type PlaceRef struct {
	Count     *int32  `json:"count,omitempty"`
	Map       *string `json:"map,omitempty"`
	Subtitle  *string `json:"subtitle,omitempty"`
	Title     *string `json:"title,omitempty"`
	Url       *string `json:"url,omitempty"`
	UtcOffset *int32  `json:"utcOffset,omitempty"`
}

// RightPageRef defines model for RightPageRef.
type RightPageRef struct {
	Page        *PlaceRef `json:"page,omitempty"`
	RightDetail *string   `json:"rightDetail,omitempty"`
	Title       *string   `json:"title,omitempty"`
}

// SearchResult defines model for SearchResult.
type SearchResult struct {
	Id     *string  `json:"_id,omitempty"`
	Score  *float32 `json:"_score,omitempty"`
	Source *struct {
		Code     *string `json:"code,omitempty"`
		Subtitle *string `json:"subtitle,omitempty"`
		Title    *string `json:"title,omitempty"`
		Type     *string `json:"type,omitempty"`
		Url      *string `json:"url,omitempty"`
	} `json:"_source,omitempty"`
}

// SearchResults defines model for SearchResults.
type SearchResults struct {
	Hits *struct {
		Hits *[]SearchResult `json:"hits,omitempty"`
	} `json:"hits,omitempty"`
	Query *string `json:"query,omitempty"`
	Took  *int32  `json:"took,omitempty"`
}

// SelectedStations defines model for SelectedStations.
type SelectedStations struct {
	Items     *[]SelectedStations_Items_Item `json:"items,omitempty"`
	ItemsType *string                        `json:"itemsType,omitempty"`
	Title     *string                        `json:"title,omitempty"`
	Type      *string                        `json:"type,omitempty"`
}

// SelectedStations_Items_Item defines model for SelectedStations.items.Item.
type SelectedStations_Items_Item struct {
	union json.RawMessage
}

// Versioned defines model for Versioned.
type Versioned struct {
	ApiVersion *int32  `json:"apiVersion,omitempty"`
	Version    *string `json:"version,omitempty"`
}

// GetSearchParams defines parameters for GetSearch.
type GetSearchParams struct {
	// Search query
	Q string `json:"q"`
}

func (t CountryPopularStations_Items_Item) AsChannelPlaceRef() (ChannelPlaceRef, error) {
	var body ChannelPlaceRef
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *CountryPopularStations_Items_Item) FromChannelPlaceRef(v ChannelPlaceRef) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t CountryPopularStations_Items_Item) AsMoreRef() (MoreRef, error) {
	var body MoreRef
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *CountryPopularStations_Items_Item) FromMoreRef(v MoreRef) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t CountryPopularStations_Items_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CountryPopularStations_Items_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t MoreRef_Page) AsPlaceRef() (PlaceRef, error) {
	var body PlaceRef
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *MoreRef_Page) FromPlaceRef(v PlaceRef) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t MoreRef_Page) AsCountryRef() (CountryRef, error) {
	var body CountryRef
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *MoreRef_Page) FromCountryRef(v CountryRef) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t MoreRef_Page) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MoreRef_Page) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t PlaceContent_Content_Item) AsSelectedStations() (SelectedStations, error) {
	var body SelectedStations
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *PlaceContent_Content_Item) FromSelectedStations(v SelectedStations) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t PlaceContent_Content_Item) AsLocalPopularStations() (LocalPopularStations, error) {
	var body LocalPopularStations
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *PlaceContent_Content_Item) FromLocalPopularStations(v LocalPopularStations) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t PlaceContent_Content_Item) AsLocalPickStations() (LocalPickStations, error) {
	var body LocalPickStations
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *PlaceContent_Content_Item) FromLocalPickStations(v LocalPickStations) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t PlaceContent_Content_Item) AsCountryPopularStations() (CountryPopularStations, error) {
	var body CountryPopularStations
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *PlaceContent_Content_Item) FromCountryPopularStations(v CountryPopularStations) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t PlaceContent_Content_Item) AsNearbyPlaces() (NearbyPlaces, error) {
	var body NearbyPlaces
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *PlaceContent_Content_Item) FromNearbyPlaces(v NearbyPlaces) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t PlaceContent_Content_Item) AsCities() (Cities, error) {
	var body Cities
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *PlaceContent_Content_Item) FromCities(v Cities) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t PlaceContent_Content_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlaceContent_Content_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t SelectedStations_Items_Item) AsChannelRef() (ChannelRef, error) {
	var body ChannelRef
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *SelectedStations_Items_Item) FromChannelRef(v ChannelRef) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t SelectedStations_Items_Item) AsMoreRef() (MoreRef, error) {
	var body MoreRef
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *SelectedStations_Items_Item) FromMoreRef(v MoreRef) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t SelectedStations_Items_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SelectedStations_Items_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAraContentChannelChannelId request
	GetAraContentChannelChannelId(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAraContentListenChannelIdChannelMp3 request
	GetAraContentListenChannelIdChannelMp3(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadAraContentListenChannelIdChannelMp3 request
	HeadAraContentListenChannelIdChannelMp3(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAraContentPagePlaceId request
	GetAraContentPagePlaceId(ctx context.Context, placeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAraContentPagePlaceIdChannels request
	GetAraContentPagePlaceIdChannels(ctx context.Context, placeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAraContentPlaces request
	GetAraContentPlaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGeo request
	GetGeo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearch request
	GetSearch(ctx context.Context, params *GetSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAraContentChannelChannelId(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAraContentChannelChannelIdRequest(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAraContentListenChannelIdChannelMp3(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAraContentListenChannelIdChannelMp3Request(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadAraContentListenChannelIdChannelMp3(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadAraContentListenChannelIdChannelMp3Request(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAraContentPagePlaceId(ctx context.Context, placeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAraContentPagePlaceIdRequest(c.Server, placeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAraContentPagePlaceIdChannels(ctx context.Context, placeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAraContentPagePlaceIdChannelsRequest(c.Server, placeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAraContentPlaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAraContentPlacesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGeo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGeoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearch(ctx context.Context, params *GetSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAraContentChannelChannelIdRequest generates requests for GetAraContentChannelChannelId
func NewGetAraContentChannelChannelIdRequest(server string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ara/content/channel/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAraContentListenChannelIdChannelMp3Request generates requests for GetAraContentListenChannelIdChannelMp3
func NewGetAraContentListenChannelIdChannelMp3Request(server string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ara/content/listen/%s/channel.mp3", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadAraContentListenChannelIdChannelMp3Request generates requests for HeadAraContentListenChannelIdChannelMp3
func NewHeadAraContentListenChannelIdChannelMp3Request(server string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ara/content/listen/%s/channel.mp3", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAraContentPagePlaceIdRequest generates requests for GetAraContentPagePlaceId
func NewGetAraContentPagePlaceIdRequest(server string, placeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "placeId", runtime.ParamLocationPath, placeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ara/content/page/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAraContentPagePlaceIdChannelsRequest generates requests for GetAraContentPagePlaceIdChannels
func NewGetAraContentPagePlaceIdChannelsRequest(server string, placeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "placeId", runtime.ParamLocationPath, placeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ara/content/page/%s/channels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAraContentPlacesRequest generates requests for GetAraContentPlaces
func NewGetAraContentPlacesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ara/content/places")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGeoRequest generates requests for GetGeo
func NewGetGeoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/geo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchRequest generates requests for GetSearch
func NewGetSearchRequest(server string, params *GetSearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAraContentChannelChannelId request
	GetAraContentChannelChannelIdWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetAraContentChannelChannelIdResponse, error)

	// GetAraContentListenChannelIdChannelMp3 request
	GetAraContentListenChannelIdChannelMp3WithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetAraContentListenChannelIdChannelMp3Response, error)

	// HeadAraContentListenChannelIdChannelMp3 request
	HeadAraContentListenChannelIdChannelMp3WithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*HeadAraContentListenChannelIdChannelMp3Response, error)

	// GetAraContentPagePlaceId request
	GetAraContentPagePlaceIdWithResponse(ctx context.Context, placeId string, reqEditors ...RequestEditorFn) (*GetAraContentPagePlaceIdResponse, error)

	// GetAraContentPagePlaceIdChannels request
	GetAraContentPagePlaceIdChannelsWithResponse(ctx context.Context, placeId string, reqEditors ...RequestEditorFn) (*GetAraContentPagePlaceIdChannelsResponse, error)

	// GetAraContentPlaces request
	GetAraContentPlacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAraContentPlacesResponse, error)

	// GetGeo request
	GetGeoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGeoResponse, error)

	// GetSearch request
	GetSearchWithResponse(ctx context.Context, params *GetSearchParams, reqEditors ...RequestEditorFn) (*GetSearchResponse, error)
}

type GetAraContentChannelChannelIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Versioned)
		Versioned `yaml:",inline"`
		// Embedded fields due to inline allOf schema
		Data *Channel `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAraContentChannelChannelIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAraContentChannelChannelIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAraContentListenChannelIdChannelMp3Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAraContentListenChannelIdChannelMp3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAraContentListenChannelIdChannelMp3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadAraContentListenChannelIdChannelMp3Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HeadAraContentListenChannelIdChannelMp3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadAraContentListenChannelIdChannelMp3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAraContentPagePlaceIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Versioned)
		Versioned `yaml:",inline"`
		// Embedded fields due to inline allOf schema
		Data *struct {
			// Embedded struct due to allOf(#/components/schemas/PlaceRef)
			PlaceRef `yaml:",inline"`
			// Embedded struct due to allOf(#/components/schemas/PlaceContent)
			PlaceContent `yaml:",inline"`
		} `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAraContentPagePlaceIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAraContentPagePlaceIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAraContentPagePlaceIdChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Versioned)
		Versioned `yaml:",inline"`
		// Embedded fields due to inline allOf schema
		Data *struct {
			// Embedded struct due to allOf(#/components/schemas/PlaceRef)
			PlaceRef `yaml:",inline"`
			// Embedded fields due to inline allOf schema
			Content *[]ChannelRefs `json:"content,omitempty"`
		} `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAraContentPagePlaceIdChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAraContentPagePlaceIdChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAraContentPlacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Versioned)
		Versioned `yaml:",inline"`
		// Embedded fields due to inline allOf schema
		Data *struct {
			List    *[]Place `json:"list,omitempty"`
			Version *string  `json:"version,omitempty"`
		} `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAraContentPlacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAraContentPlacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGeoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Geolocation
}

// Status returns HTTPResponse.Status
func (r GetGeoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGeoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Versioned)
		Versioned `yaml:",inline"`
		// Embedded struct due to allOf(#/components/schemas/SearchResults)
		SearchResults `yaml:",inline"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAraContentChannelChannelIdWithResponse request returning *GetAraContentChannelChannelIdResponse
func (c *ClientWithResponses) GetAraContentChannelChannelIdWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetAraContentChannelChannelIdResponse, error) {
	rsp, err := c.GetAraContentChannelChannelId(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAraContentChannelChannelIdResponse(rsp)
}

// GetAraContentListenChannelIdChannelMp3WithResponse request returning *GetAraContentListenChannelIdChannelMp3Response
func (c *ClientWithResponses) GetAraContentListenChannelIdChannelMp3WithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetAraContentListenChannelIdChannelMp3Response, error) {
	rsp, err := c.GetAraContentListenChannelIdChannelMp3(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAraContentListenChannelIdChannelMp3Response(rsp)
}

// HeadAraContentListenChannelIdChannelMp3WithResponse request returning *HeadAraContentListenChannelIdChannelMp3Response
func (c *ClientWithResponses) HeadAraContentListenChannelIdChannelMp3WithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*HeadAraContentListenChannelIdChannelMp3Response, error) {
	rsp, err := c.HeadAraContentListenChannelIdChannelMp3(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadAraContentListenChannelIdChannelMp3Response(rsp)
}

// GetAraContentPagePlaceIdWithResponse request returning *GetAraContentPagePlaceIdResponse
func (c *ClientWithResponses) GetAraContentPagePlaceIdWithResponse(ctx context.Context, placeId string, reqEditors ...RequestEditorFn) (*GetAraContentPagePlaceIdResponse, error) {
	rsp, err := c.GetAraContentPagePlaceId(ctx, placeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAraContentPagePlaceIdResponse(rsp)
}

// GetAraContentPagePlaceIdChannelsWithResponse request returning *GetAraContentPagePlaceIdChannelsResponse
func (c *ClientWithResponses) GetAraContentPagePlaceIdChannelsWithResponse(ctx context.Context, placeId string, reqEditors ...RequestEditorFn) (*GetAraContentPagePlaceIdChannelsResponse, error) {
	rsp, err := c.GetAraContentPagePlaceIdChannels(ctx, placeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAraContentPagePlaceIdChannelsResponse(rsp)
}

// GetAraContentPlacesWithResponse request returning *GetAraContentPlacesResponse
func (c *ClientWithResponses) GetAraContentPlacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAraContentPlacesResponse, error) {
	rsp, err := c.GetAraContentPlaces(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAraContentPlacesResponse(rsp)
}

// GetGeoWithResponse request returning *GetGeoResponse
func (c *ClientWithResponses) GetGeoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGeoResponse, error) {
	rsp, err := c.GetGeo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGeoResponse(rsp)
}

// GetSearchWithResponse request returning *GetSearchResponse
func (c *ClientWithResponses) GetSearchWithResponse(ctx context.Context, params *GetSearchParams, reqEditors ...RequestEditorFn) (*GetSearchResponse, error) {
	rsp, err := c.GetSearch(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchResponse(rsp)
}

// ParseGetAraContentChannelChannelIdResponse parses an HTTP response from a GetAraContentChannelChannelIdWithResponse call
func ParseGetAraContentChannelChannelIdResponse(rsp *http.Response) (*GetAraContentChannelChannelIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAraContentChannelChannelIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded struct due to allOf(#/components/schemas/Versioned)
			Versioned `yaml:",inline"`
			// Embedded fields due to inline allOf schema
			Data *Channel `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAraContentListenChannelIdChannelMp3Response parses an HTTP response from a GetAraContentListenChannelIdChannelMp3WithResponse call
func ParseGetAraContentListenChannelIdChannelMp3Response(rsp *http.Response) (*GetAraContentListenChannelIdChannelMp3Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAraContentListenChannelIdChannelMp3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHeadAraContentListenChannelIdChannelMp3Response parses an HTTP response from a HeadAraContentListenChannelIdChannelMp3WithResponse call
func ParseHeadAraContentListenChannelIdChannelMp3Response(rsp *http.Response) (*HeadAraContentListenChannelIdChannelMp3Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadAraContentListenChannelIdChannelMp3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAraContentPagePlaceIdResponse parses an HTTP response from a GetAraContentPagePlaceIdWithResponse call
func ParseGetAraContentPagePlaceIdResponse(rsp *http.Response) (*GetAraContentPagePlaceIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAraContentPagePlaceIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded struct due to allOf(#/components/schemas/Versioned)
			Versioned `yaml:",inline"`
			// Embedded fields due to inline allOf schema
			Data *struct {
				// Embedded struct due to allOf(#/components/schemas/PlaceRef)
				PlaceRef `yaml:",inline"`
				// Embedded struct due to allOf(#/components/schemas/PlaceContent)
				PlaceContent `yaml:",inline"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAraContentPagePlaceIdChannelsResponse parses an HTTP response from a GetAraContentPagePlaceIdChannelsWithResponse call
func ParseGetAraContentPagePlaceIdChannelsResponse(rsp *http.Response) (*GetAraContentPagePlaceIdChannelsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAraContentPagePlaceIdChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded struct due to allOf(#/components/schemas/Versioned)
			Versioned `yaml:",inline"`
			// Embedded fields due to inline allOf schema
			Data *struct {
				// Embedded struct due to allOf(#/components/schemas/PlaceRef)
				PlaceRef `yaml:",inline"`
				// Embedded fields due to inline allOf schema
				Content *[]ChannelRefs `json:"content,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAraContentPlacesResponse parses an HTTP response from a GetAraContentPlacesWithResponse call
func ParseGetAraContentPlacesResponse(rsp *http.Response) (*GetAraContentPlacesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAraContentPlacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded struct due to allOf(#/components/schemas/Versioned)
			Versioned `yaml:",inline"`
			// Embedded fields due to inline allOf schema
			Data *struct {
				List    *[]Place `json:"list,omitempty"`
				Version *string  `json:"version,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGeoResponse parses an HTTP response from a GetGeoWithResponse call
func ParseGetGeoResponse(rsp *http.Response) (*GetGeoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGeoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Geolocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSearchResponse parses an HTTP response from a GetSearchWithResponse call
func ParseGetSearchResponse(rsp *http.Response) (*GetSearchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded struct due to allOf(#/components/schemas/Versioned)
			Versioned `yaml:",inline"`
			// Embedded struct due to allOf(#/components/schemas/SearchResults)
			SearchResults `yaml:",inline"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
